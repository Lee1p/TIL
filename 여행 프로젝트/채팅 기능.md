## WebSocket

실시간 대화 구현하기위해서 WebSocket 프로토콜 사용을 해야한다. 
기존 HTTP 통신은 요청-응답 방식이라서 클라이언트가 요청을 보내야 서버가 응답하는 구조인데, WebSocket은 서버와 클라이언트가 항상 연결된 상태에서 실시간 데이터를 주고받을 수 있도록 해준다.

✅ 양방향 통신: 클라이언트가 요청을 보내지 않아도 서버가 데이터를 실시간으로 보낼 수 있음 </br>
✅ 연결 유지: WebSocket은 한 번 연결되면 계속 유지되어 불필요한 요청을 줄일 수 있음  
✅ 빠른 데이터 전송: HTTP보다 더 가벼운 프로토콜을 사용하여 실시간 성능이 뛰어남 


1. build.gradle에 웹소켓 관련된 implementation 추가
```
implementation 'org.springframework.boot:spring-boot-starter-websocket'
```
📌 WebSocketConfig는 어떤 역할을 할까?
이 설정 클래스는 웹소켓 서버를 설정하는 역할을 해. HTTP처럼 WebSocket도 서버와 클라이언트가 통신할 수 있는 연결 규칙이 필요하고, 그걸 이 @Configuration 클래스를 통해 정의

✅ Q1. @EnableWebSocketMessageBroker는 왜 꼭 필요할까?

"웹소켓 기반의 메시지 라우팅 시스템을 사용하기 위한 어노테이션이다."

💬 쉽게 말하면:
이 어노테이션을 붙이면
→ Spring 내부에 메시지를 주고받는 메시지 통신 허브를 만들어줘
→ 클라이언트가 메시지를 보내고, 서버가 받아서 처리하고, 다시 여러 사용자에게 브로드캐스트하는 “중간 관리자” 역할이 생겨

✅ Q2. STOMP는 왜 쓰는 걸까?
📦 WebSocket은 기본적으로 "낮은 수준"의 통신만 제공해
그냥 데이터만 주고받는 구조 (프로토콜 없음)

→ 내가 누구에게 보냈는지, 어디로 보내야 할지 정하는 건 개발자가 다 직접 구현

 1. 엔드포인트 (Endpoint) = 서버에 연결하는 "입구 URL"
"클라이언트가 웹소켓 연결을 시도할 때 접속하는 URL"


브로드캐스트 예시
예: 카톡 단체방
너가 메시지를 한 번 보내면

그 방에 있는 모든 사람이 동시에 그 메시지를 받지?

→ 이게 브로드캐스트야.


